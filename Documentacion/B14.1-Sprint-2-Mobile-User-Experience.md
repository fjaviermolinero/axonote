# B14.1 - Sprint 2: Mobile & User Experience
## AxoNote - Desarrollo Móvil y Optimización UX

---

## 📋 RESUMEN EJECUTIVO

El **Sprint 2: Mobile & User Experience** se enfoca en expandir AxoNote hacia plataformas móviles nativas y mejorar significativamente la experiencia de usuario. Este sprint transformará AxoNote de una PWA funcional a un ecosistema completo multiplataforma con capacidades offline-first y funcionalidades móviles avanzadas.

### 🎯 **Objetivos Principales**
1. **React Native App**: Aplicación móvil nativa completa
2. **PWA Enhancement**: Mejoras avanzadas Progressive Web App
3. **Offline-First**: Arquitectura de sincronización inteligente
4. **Camera & OCR**: Captura directa de documentos médicos
5. **User Onboarding**: Flujo de usuarios optimizado

### ⏱️ **Duración Estimada**: 3-4 semanas
### 🔥 **Prioridad**: ALTA

---

## 🚀 **FASE 2.1: REACT NATIVE APP NATIVA**
### *Duración: 3 semanas | Prioridad: CRÍTICA*

### **Objetivo**
Desarrollar aplicación móvil nativa completa que proporcione funcionalidad de captura, procesamiento y consumo de contenido médico con experiencia optimizada para dispositivos móviles.

### **Arquitectura Técnica**

#### **Stack Tecnológico**
```typescript
// React Native 0.72+
// TypeScript strict mode
// Expo SDK 49+ (managed workflow)
// React Navigation 6
// Zustand (state management)
// SQLite (local storage)
// React Query (server state)
// Expo Camera
// Expo Audio
// Expo FileSystem
// React Native Reanimated 3
```

#### **Estructura del Proyecto**
```
apps/mobile/
├── src/
│   ├── components/
│   │   ├── recording/
│   │   │   ├── RecordingButton.tsx
│   │   │   ├── AudioWaveform.tsx
│   │   │   └── RecordingControls.tsx
│   │   ├── camera/
│   │   │   ├── DocumentCamera.tsx
│   │   │   ├── OCRPreview.tsx
│   │   │   └── CropOverlay.tsx
│   │   ├── sync/
│   │   │   ├── SyncIndicator.tsx
│   │   │   ├── OfflineQueue.tsx
│   │   │   └── ConflictResolver.tsx
│   │   └── study/
│   │       ├── FlashcardView.tsx
│   │       ├── TTSPlayer.tsx
│   │       └── StudyProgress.tsx
│   ├── screens/
│   │   ├── HomeScreen.tsx
│   │   ├── RecordingScreen.tsx
│   │   ├── CameraScreen.tsx
│   │   ├── StudyScreen.tsx
│   │   ├── SyncScreen.tsx
│   │   └── SettingsScreen.tsx
│   ├── services/
│   │   ├── api/
│   │   │   ├── axonoteApi.ts
│   │   │   ├── uploadService.ts
│   │   │   └── syncService.ts
│   │   ├── storage/
│   │   │   ├── sqliteService.ts
│   │   │   ├── fileService.ts
│   │   │   └── cacheService.ts
│   │   ├── audio/
│   │   │   ├── recordingService.ts
│   │   │   ├── compressionService.ts
│   │   │   └── vadService.ts
│   │   ├── camera/
│   │   │   ├── ocrService.ts
│   │   │   ├── documentDetection.ts
│   │   │   └── imageProcessing.ts
│   │   └── sync/
│   │       ├── backgroundSync.ts
│   │       ├── conflictResolution.ts
│   │       └── queueManager.ts
│   ├── store/
│   │   ├── authStore.ts
│   │   ├── recordingStore.ts
│   │   ├── syncStore.ts
│   │   └── settingsStore.ts
│   ├── utils/
│   │   ├── permissions.ts
│   │   ├── notifications.ts
│   │   └── analytics.ts
│   └── types/
│       ├── api.ts
│       ├── storage.ts
│       └── navigation.ts
├── app.json
├── package.json
└── README.md
```

### **Features Principales**

#### **🎙️ Recording Optimizado Móvil**
```typescript
interface MobileRecordingConfig {
  // Configuración optimizada para móviles
  sampleRate: 44100 | 48000;
  bitRate: 128000 | 256000;
  channels: 1 | 2;
  format: 'aac' | 'mp3' | 'wav';
  
  // Voice Activity Detection móvil
  vadEnabled: boolean;
  vadSensitivity: 'low' | 'medium' | 'high';
  
  // Compresión adaptativa
  compressionLevel: 'mobile' | 'balanced' | 'quality';
  
  // Background recording
  backgroundMode: boolean;
  maxDuration: number; // segundos
}

class MobileRecordingService {
  async startRecording(config: MobileRecordingConfig): Promise<void>
  async pauseRecording(): Promise<void>
  async resumeRecording(): Promise<void>
  async stopRecording(): Promise<RecordingResult>
  
  // Monitoreo en tiempo real
  onAmplitudeChange(callback: (amplitude: number) => void): void
  onVADDetection(callback: (speaking: boolean) => void): void
  
  // Gestión de archivos
  async compressAudio(uri: string): Promise<string>
  async uploadChunked(uri: string): Promise<UploadSession>
}
```

#### **📷 Camera & OCR Integration**
```typescript
interface DocumentCaptureConfig {
  // Detección automática documentos
  autoDetection: boolean;
  documentTypes: ('medical_report' | 'prescription' | 'notes' | 'textbook')[];
  
  // Mejora de calidad
  autoEnhancement: boolean;
  cropAutomatically: boolean;
  
  // OCR en dispositivo
  onDeviceOCR: boolean;
  languages: string[]; // ['ita', 'eng', 'lat']
}

class DocumentCameraService {
  async captureDocument(config: DocumentCaptureConfig): Promise<DocumentResult>
  async processImage(uri: string): Promise<OCRResult>
  async enhanceImage(uri: string): Promise<string>
  
  // Detección de documentos médicos
  async detectMedicalContent(uri: string): Promise<MedicalContentType>
  async extractMedicalTerms(text: string): Promise<MedicalTerm[]>
}

interface DocumentResult {
  imageUri: string;
  croppedUri?: string;
  ocrText?: string;
  medicalTerms?: MedicalTerm[];
  confidence: number;
  processingTime: number;
}
```

#### **🔄 Offline-First Architecture**
```typescript
interface SyncStrategy {
  // Estrategias de sincronización
  mode: 'immediate' | 'wifi_only' | 'scheduled' | 'manual';
  
  // Configuración de red
  maxRetries: number;
  retryDelay: number;
  batchSize: number;
  
  // Resolución de conflictos
  conflictResolution: 'server_wins' | 'client_wins' | 'manual';
  
  // Prioridades
  priorityQueues: {
    high: string[]; // tipos de datos críticos
    medium: string[];
    low: string[];
  };
}

class OfflineSyncService {
  // Gestión de cola offline
  async queueForSync(data: SyncableData): Promise<void>
  async processQueue(): Promise<SyncResult[]>
  async resolveConflicts(): Promise<ConflictResolution[]>
  
  // Monitoreo de conectividad
  onConnectivityChange(callback: (connected: boolean) => void): void
  async syncWhenOnline(): Promise<void>
  
  // Estadísticas de sync
  getSyncStats(): Promise<SyncStats>
  getPendingItems(): Promise<PendingItem[]>
}
```

### **Componentes UI Especializados**

#### **RecordingButton Avanzado**
```typescript
interface RecordingButtonProps {
  size: 'small' | 'medium' | 'large';
  variant: 'medical' | 'lecture' | 'note';
  showWaveform: boolean;
  showTimer: boolean;
  vadEnabled: boolean;
}

const RecordingButton: React.FC<RecordingButtonProps> = ({
  size,
  variant,
  showWaveform,
  showTimer,
  vadEnabled
}) => {
  // Animaciones fluidas con Reanimated
  // Feedback háptico
  // Visualización en tiempo real
  // Gestión de estados complejos
};
```

#### **DocumentCamera Component**
```typescript
interface DocumentCameraProps {
  onCapture: (result: DocumentResult) => void;
  autoDetection: boolean;
  medicalMode: boolean;
  languages: string[];
}

const DocumentCamera: React.FC<DocumentCameraProps> = ({
  onCapture,
  autoDetection,
  medicalMode,
  languages
}) => {
  // Overlay de detección automática
  // Guías visuales para captura
  // Preview con crop automático
  // OCR en tiempo real
};
```

### **Navegación y UX**

#### **Navigation Stack**
```typescript
type RootStackParamList = {
  Home: undefined;
  Recording: { sessionId?: string };
  Camera: { mode: 'document' | 'whiteboard' | 'prescription' };
  Study: { collectionId: string };
  Sync: undefined;
  Settings: undefined;
  Profile: undefined;
};

// Bottom Tab Navigation
type TabParamList = {
  Home: undefined;
  Record: undefined;
  Camera: undefined;
  Study: undefined;
  Profile: undefined;
};
```

#### **Gestos y Interacciones**
```typescript
// Gestos personalizados para médicos
interface MedicalGestures {
  // Grabación rápida
  longPressRecord: boolean;
  
  // Navegación rápida
  swipeToStudy: boolean;
  
  // Acciones contextuales
  doubleTapToBookmark: boolean;
  
  // Accesibilidad
  voiceCommands: boolean;
  largeTextMode: boolean;
}
```

### **Performance Optimizations**

#### **Lazy Loading y Code Splitting**
```typescript
// Lazy loading de screens
const RecordingScreen = lazy(() => import('./screens/RecordingScreen'));
const CameraScreen = lazy(() => import('./screens/CameraScreen'));
const StudyScreen = lazy(() => import('./screens/StudyScreen'));

// Preloading inteligente
class PreloadingService {
  async preloadCriticalAssets(): Promise<void>
  async preloadUserContent(): Promise<void>
  async warmupServices(): Promise<void>
}
```

#### **Memory Management**
```typescript
interface MemoryConfig {
  // Límites de cache
  maxCacheSize: number; // MB
  maxAudioFiles: number;
  maxImages: number;
  
  // Limpieza automática
  autoCleanup: boolean;
  cleanupThreshold: number; // %
  
  // Compresión
  compressOldFiles: boolean;
  compressionDelay: number; // días
}
```

---

## 🌐 **FASE 2.2: PWA ENHANCEMENT AVANZADO**
### *Duración: 1 semana | Prioridad: ALTA*

### **Objetivo**
Mejorar la Progressive Web App existente con funcionalidades avanzadas, optimización de performance y mejor integración con el ecosistema móvil.

### **Advanced PWA Features**

#### **Install Prompts Inteligentes**
```typescript
interface InstallPromptConfig {
  // Triggers inteligentes
  triggers: {
    sessionCount: number;
    timeSpent: number; // minutos
    featuresUsed: string[];
    userEngagement: 'high' | 'medium' | 'low';
  };
  
  // Personalización
  customMessage: string;
  showBenefits: boolean;
  deferralLimit: number;
  
  // A/B Testing
  variant: 'minimal' | 'detailed' | 'interactive';
}

class InstallPromptService {
  async shouldShowPrompt(): Promise<boolean>
  async showInstallPrompt(): Promise<InstallResult>
  async trackInstallMetrics(): Promise<void>
  
  // Analytics de instalación
  getInstallStats(): Promise<InstallStats>
}
```

#### **Background Sync Mejorado**
```typescript
interface BackgroundSyncConfig {
  // Estrategias de sync
  strategies: {
    immediate: string[]; // tipos de datos críticos
    periodic: string[]; // sync periódico
    onDemand: string[]; // sync manual
  };
  
  // Configuración de red
  networkConditions: {
    wifiOnly: boolean;
    maxRetries: number;
    exponentialBackoff: boolean;
  };
  
  // Notificaciones
  notifyOnComplete: boolean;
  notifyOnError: boolean;
}

// Service Worker avanzado
class AdvancedServiceWorker {
  // Background sync inteligente
  async registerBackgroundSync(tag: string, data: any): Promise<void>
  async handleBackgroundSync(event: SyncEvent): Promise<void>
  
  // Cache strategies
  async cacheFirst(request: Request): Promise<Response>
  async networkFirst(request: Request): Promise<Response>
  async staleWhileRevalidate(request: Request): Promise<Response>
  
  // Offline analytics
  async trackOfflineUsage(): Promise<void>
  async syncOfflineAnalytics(): Promise<void>
}
```

#### **Share Target API Integration**
```typescript
interface ShareTargetConfig {
  // Tipos de contenido aceptados
  acceptedTypes: {
    audio: string[]; // ['audio/mp3', 'audio/wav', 'audio/aac']
    image: string[]; // ['image/jpeg', 'image/png', 'image/webp']
    text: string[]; // ['text/plain', 'text/markdown']
    files: string[]; // ['application/pdf', 'application/msword']
  };
  
  // Procesamiento automático
  autoProcess: boolean;
  showPreview: boolean;
  
  // Integración con sistema
  registerAsHandler: boolean;
}

class ShareTargetHandler {
  async handleSharedContent(data: ShareData): Promise<ProcessResult>
  async processSharedAudio(file: File): Promise<void>
  async processSharedImage(file: File): Promise<void>
  async processSharedText(text: string): Promise<void>
}
```

### **Performance Optimization Avanzada**

#### **Code Splitting Inteligente**
```typescript
// Route-based splitting
const routes = [
  {
    path: '/dashboard',
    component: lazy(() => import('./pages/Dashboard')),
    preload: true
  },
  {
    path: '/recording',
    component: lazy(() => import('./pages/Recording')),
    preload: false
  },
  {
    path: '/study',
    component: lazy(() => import('./pages/Study')),
    preload: false
  }
];

// Component-based splitting
const HeavyComponent = lazy(() => 
  import('./components/HeavyComponent').then(module => ({
    default: module.HeavyComponent
  }))
);

// Feature-based splitting
const advancedFeatures = lazy(() => import('./features/advanced'));
```

#### **Image Optimization Automática**
```typescript
interface ImageOptimizationConfig {
  // Formatos soportados
  formats: ('webp' | 'avif' | 'jpeg' | 'png')[];
  
  // Calidades por dispositivo
  qualities: {
    mobile: number;
    tablet: number;
    desktop: number;
  };
  
  // Lazy loading
  lazyLoading: boolean;
  placeholder: 'blur' | 'skeleton' | 'none';
  
  // Responsive images
  breakpoints: number[];
  sizes: string;
}

class ImageOptimizer {
  async optimizeImage(src: string, config: ImageOptimizationConfig): Promise<OptimizedImage>
  async generateResponsiveSizes(src: string): Promise<ResponsiveImageSet>
  async preloadCriticalImages(): Promise<void>
}
```

#### **Bundle Size Optimization**
```typescript
// Webpack/Vite optimization
const optimizationConfig = {
  // Tree shaking
  usedExports: true,
  sideEffects: false,
  
  // Minification
  minimize: true,
  minimizer: ['terser', 'css-minimizer'],
  
  // Splitting
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all',
      },
      common: {
        name: 'common',
        minChunks: 2,
        chunks: 'all',
      }
    }
  }
};
```

### **Service Worker Strategy Optimization**

#### **Cache Strategies Avanzadas**
```typescript
interface CacheStrategy {
  // Estrategias por tipo de recurso
  strategies: {
    api: 'networkFirst' | 'cacheFirst' | 'staleWhileRevalidate';
    assets: 'cacheFirst' | 'immutable';
    pages: 'networkFirst' | 'cacheFirst';
    images: 'cacheFirst' | 'staleWhileRevalidate';
  };
  
  // TTL por tipo
  ttl: {
    api: number; // segundos
    assets: number;
    pages: number;
    images: number;
  };
  
  // Límites de cache
  maxEntries: {
    api: number;
    assets: number;
    pages: number;
    images: number;
  };
}

class AdvancedCacheManager {
  async implementStrategy(request: Request): Promise<Response>
  async cleanupExpiredCache(): Promise<void>
  async preloadCriticalResources(): Promise<void>
  
  // Analytics de cache
  getCacheStats(): Promise<CacheStats>
  getHitRatio(): Promise<number>
}
```

---

## 📱 **FASE 2.3: OFFLINE-FIRST ARCHITECTURE**
### *Duración: 1 semana | Prioridad: ALTA*

### **Objetivo**
Implementar arquitectura robusta offline-first que permita funcionalidad completa sin conexión a internet, con sincronización inteligente cuando la conectividad se restaura.

### **SQLite Local Storage**

#### **Database Schema Móvil**
```sql
-- Esquema optimizado para móvil
CREATE TABLE local_sessions (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  audio_path TEXT,
  duration INTEGER,
  created_at INTEGER,
  updated_at INTEGER,
  sync_status TEXT DEFAULT 'pending', -- pending, syncing, synced, error
  sync_attempts INTEGER DEFAULT 0,
  metadata TEXT -- JSON
);

CREATE TABLE local_transcriptions (
  id TEXT PRIMARY KEY,
  session_id TEXT REFERENCES local_sessions(id),
  text TEXT,
  confidence REAL,
  speakers TEXT, -- JSON array
  timestamps TEXT, -- JSON array
  sync_status TEXT DEFAULT 'pending'
);

CREATE TABLE local_ocr_results (
  id TEXT PRIMARY KEY,
  image_path TEXT,
  extracted_text TEXT,
  medical_terms TEXT, -- JSON array
  confidence REAL,
  created_at INTEGER,
  sync_status TEXT DEFAULT 'pending'
);

CREATE TABLE local_micro_memos (
  id TEXT PRIMARY KEY,
  session_id TEXT REFERENCES local_sessions(id),
  type TEXT, -- flashcard, summary, quiz, etc.
  content TEXT, -- JSON
  difficulty INTEGER,
  last_reviewed INTEGER,
  next_review INTEGER,
  sync_status TEXT DEFAULT 'pending'
);

CREATE TABLE sync_queue (
  id TEXT PRIMARY KEY,
  operation_type TEXT, -- create, update, delete
  table_name TEXT,
  record_id TEXT,
  data TEXT, -- JSON
  priority INTEGER DEFAULT 1, -- 1=high, 2=medium, 3=low
  created_at INTEGER,
  attempts INTEGER DEFAULT 0,
  last_attempt INTEGER,
  error_message TEXT
);
```

#### **SQLite Service**
```typescript
interface SQLiteConfig {
  databaseName: string;
  version: number;
  
  // Performance
  journalMode: 'DELETE' | 'TRUNCATE' | 'PERSIST' | 'MEMORY' | 'WAL';
  synchronous: 'OFF' | 'NORMAL' | 'FULL' | 'EXTRA';
  
  // Cache
  cacheSize: number; // páginas
  tempStore: 'DEFAULT' | 'FILE' | 'MEMORY';
  
  // Backup
  autoBackup: boolean;
  backupInterval: number; // horas
}

class SQLiteService {
  // Operaciones CRUD optimizadas
  async create<T>(table: string, data: T): Promise<string>
  async read<T>(table: string, id: string): Promise<T | null>
  async update<T>(table: string, id: string, data: Partial<T>): Promise<void>
  async delete(table: string, id: string): Promise<void>
  
  // Queries complejas
  async query<T>(sql: string, params?: any[]): Promise<T[]>
  async transaction(operations: () => Promise<void>): Promise<void>
  
  // Sincronización
  async markForSync(table: string, id: string, operation: SyncOperation): Promise<void>
  async getSyncQueue(): Promise<SyncQueueItem[]>
  async clearSyncQueue(): Promise<void>
  
  // Mantenimiento
  async vacuum(): Promise<void>
  async backup(): Promise<string>
  async restore(backupPath: string): Promise<void>
}
```

### **Sync Inteligente Background**

#### **Conflict Resolution Engine**
```typescript
interface ConflictResolutionStrategy {
  // Estrategias por tipo de dato
  strategies: {
    sessions: 'server_wins' | 'client_wins' | 'merge' | 'manual';
    transcriptions: 'server_wins' | 'client_wins' | 'merge' | 'manual';
    user_data: 'server_wins' | 'client_wins' | 'merge' | 'manual';
  };
  
  // Reglas de merge
  mergeRules: {
    timestampField: string;
    versionField?: string;
    conflictFields: string[];
  };
  
  // Notificaciones
  notifyUser: boolean;
  autoResolve: boolean;
}

class ConflictResolver {
  async detectConflicts(localData: any, serverData: any): Promise<Conflict[]>
  async resolveConflict(conflict: Conflict, strategy: ResolutionStrategy): Promise<ResolvedData>
  async mergeData(local: any, server: any, rules: MergeRules): Promise<any>
  
  // UI para resolución manual
  async showConflictResolutionUI(conflicts: Conflict[]): Promise<Resolution[]>
}

interface Conflict {
  id: string;
  table: string;
  field: string;
  localValue: any;
  serverValue: any;
  lastModified: {
    local: number;
    server: number;
  };
}
```

#### **Background Sync Manager**
```typescript
interface BackgroundSyncConfig {
  // Triggers de sincronización
  triggers: {
    onNetworkRestore: boolean;
    periodic: boolean;
    onAppForeground: boolean;
    onBatteryChange: boolean;
  };
  
  // Condiciones de red
  networkRequirements: {
    wifiOnly: boolean;
    minimumBandwidth: number; // kbps
    maxCellularUsage: number; // MB
  };
  
  // Batería
  batteryRequirements: {
    minimumLevel: number; // %
    requiresCharging: boolean;
  };
  
  // Prioridades
  priorityQueues: {
    critical: string[]; // tipos de datos críticos
    normal: string[];
    background: string[];
  };
}

class BackgroundSyncManager {
  // Gestión de cola
  async addToQueue(item: SyncItem, priority: Priority): Promise<void>
  async processQueue(): Promise<SyncResult[]>
  async pauseSync(): Promise<void>
  async resumeSync(): Promise<void>
  
  // Monitoreo de condiciones
  async checkSyncConditions(): Promise<boolean>
  async waitForOptimalConditions(): Promise<void>
  
  // Estadísticas
  getSyncProgress(): Promise<SyncProgress>
  getFailedItems(): Promise<FailedSyncItem[]>
  
  // Notificaciones
  onSyncComplete(callback: (result: SyncResult) => void): void
  onSyncError(callback: (error: SyncError) => void): void
}
```

### **Offline Analytics Storage**

#### **Analytics Buffer**
```typescript
interface OfflineAnalyticsConfig {
  // Buffer settings
  maxEvents: number;
  maxAge: number; // días
  
  // Batching
  batchSize: number;
  flushInterval: number; // minutos
  
  // Compression
  compressEvents: boolean;
  compressionThreshold: number; // eventos
  
  // Privacy
  anonymizeData: boolean;
  excludeFields: string[];
}

class OfflineAnalyticsService {
  // Event tracking
  async trackEvent(event: AnalyticsEvent): Promise<void>
  async trackUserAction(action: UserAction): Promise<void>
  async trackPerformance(metrics: PerformanceMetrics): Promise<void>
  
  // Buffering
  async bufferEvent(event: AnalyticsEvent): Promise<void>
  async flushBuffer(): Promise<void>
  async compressBuffer(): Promise<void>
  
  // Sync
  async syncAnalytics(): Promise<void>
  async getBufferedEvents(): Promise<AnalyticsEvent[]>
  
  // Privacy
  async anonymizeEvent(event: AnalyticsEvent): Promise<AnalyticsEvent>
  async clearPersonalData(): Promise<void>
}
```

---

## 📷 **FASE 2.4: CAMERA & OCR INTEGRATION**
### *Duración: 1 semana | Prioridad: MEDIA*

### **Objetivo**
Integrar captura de cámara avanzada con OCR en dispositivo para documentos médicos, permitiendo digitalización instantánea de prescripciones, reportes y notas manuscritas.

### **Document Detection Engine**

#### **Computer Vision Pipeline**
```typescript
interface DocumentDetectionConfig {
  // Tipos de documentos médicos
  documentTypes: {
    prescription: boolean;
    medicalReport: boolean;
    labResults: boolean;
    handwrittenNotes: boolean;
    textbook: boolean;
  };
  
  // Configuración de detección
  detection: {
    minConfidence: number; // 0-1
    edgeDetection: boolean;
    cornerDetection: boolean;
    autoRotation: boolean;
  };
  
  // Mejora de imagen
  enhancement: {
    autoContrast: boolean;
    denoising: boolean;
    sharpening: boolean;
    perspectiveCorrection: boolean;
  };
}

class DocumentDetectionEngine {
  // Detección automática
  async detectDocument(imageUri: string): Promise<DocumentDetectionResult>
  async detectCorners(imageUri: string): Promise<Point[]>
  async detectOrientation(imageUri: string): Promise<number>
  
  // Clasificación de documentos
  async classifyDocument(imageUri: string): Promise<DocumentType>
  async extractRegionsOfInterest(imageUri: string): Promise<Region[]>
  
  // Mejora de calidad
  async enhanceImage(imageUri: string, config: EnhancementConfig): Promise<string>
  async correctPerspective(imageUri: string, corners: Point[]): Promise<string>
  async cropToDocument(imageUri: string): Promise<string>
}

interface DocumentDetectionResult {
  detected: boolean;
  confidence: number;
  corners: Point[];
  documentType: DocumentType;
  orientation: number;
  suggestedCrop: Rectangle;
}
```

#### **On-Device OCR Service**
```typescript
interface OCRConfig {
  // Idiomas soportados
  languages: ('ita' | 'eng' | 'lat' | 'fra' | 'deu')[];
  
  // Modos de reconocimiento
  mode: 'fast' | 'accurate' | 'medical';
  
  // Post-procesamiento
  postProcessing: {
    spellCheck: boolean;
    medicalTermCorrection: boolean;
    contextualCorrection: boolean;
  };
  
  // Configuración médica
  medicalMode: {
    enabled: boolean;
    terminologyDatabase: string;
    dosageRecognition: boolean;
    drugNameRecognition: boolean;
  };
}

class OnDeviceOCRService {
  // OCR principal
  async extractText(imageUri: string, config: OCRConfig): Promise<OCRResult>
  async extractTextWithRegions(imageUri: string): Promise<RegionOCRResult[]>
  
  // Reconocimiento médico especializado
  async extractMedicalTerms(text: string): Promise<MedicalTerm[]>
  async extractDosageInfo(text: string): Promise<DosageInfo[]>
  async extractDrugNames(text: string): Promise<DrugInfo[]>
  
  // Post-procesamiento
  async correctMedicalTerms(text: string): Promise<string>
  async validateMedicalContent(text: string): Promise<ValidationResult>
  
  // Performance
  async warmupModel(): Promise<void>
  async getModelInfo(): Promise<ModelInfo>
}

interface OCRResult {
  text: string;
  confidence: number;
  regions: TextRegion[];
  medicalTerms: MedicalTerm[];
  processingTime: number;
  language: string;
}
```

### **Camera UI Components**

#### **Advanced Camera Interface**
```typescript
interface CameraInterfaceProps {
  mode: 'document' | 'whiteboard' | 'prescription';
  autoCapture: boolean;
  showOverlay: boolean;
  onCapture: (result: CaptureResult) => void;
  onOCRComplete: (result: OCRResult) => void;
}

const AdvancedCameraInterface: React.FC<CameraInterfaceProps> = ({
  mode,
  autoCapture,
  showOverlay,
  onCapture,
  onOCRComplete
}) => {
  // Estado de la cámara
  const [cameraReady, setCameraReady] = useState(false);
  const [documentDetected, setDocumentDetected] = useState(false);
  const [ocrInProgress, setOCRInProgress] = useState(false);
  
  // Overlay de detección
  const renderDetectionOverlay = () => (
    <DocumentDetectionOverlay
      corners={detectedCorners}
      confidence={detectionConfidence}
      documentType={documentType}
    />
  );
  
  // Controles de cámara
  const renderCameraControls = () => (
    <CameraControls
      onCapture={handleCapture}
      onFlashToggle={toggleFlash}
      onModeSwitch={switchMode}
      autoCapture={autoCapture}
    />
  );
  
  return (
    <View style={styles.container}>
      <Camera
        style={styles.camera}
        onCameraReady={() => setCameraReady(true)}
        onBarCodeScanned={handleBarCodeScanned}
      />
      {showOverlay && renderDetectionOverlay()}
      {renderCameraControls()}
      {ocrInProgress && <OCRProgressIndicator />}
    </View>
  );
};
```

#### **OCR Preview Component**
```typescript
interface OCRPreviewProps {
  imageUri: string;
  ocrResult: OCRResult;
  onEdit: (editedText: string) => void;
  onConfirm: () => void;
  onRetake: () => void;
}

const OCRPreview: React.FC<OCRPreviewProps> = ({
  imageUri,
  ocrResult,
  onEdit,
  onConfirm,
  onRetake
}) => {
  const [editedText, setEditedText] = useState(ocrResult.text);
  const [selectedRegion, setSelectedRegion] = useState<TextRegion | null>(null);
  
  // Overlay interactivo sobre la imagen
  const renderTextRegions = () => (
    <ImageOverlay imageUri={imageUri}>
      {ocrResult.regions.map((region, index) => (
        <TouchableRegion
          key={index}
          region={region}
          onPress={() => setSelectedRegion(region)}
          highlighted={selectedRegion === region}
        />
      ))}
    </ImageOverlay>
  );
  
  // Editor de texto con highlighting
  const renderTextEditor = () => (
    <TextEditor
      value={editedText}
      onChangeText={setEditedText}
      medicalTerms={ocrResult.medicalTerms}
      onTermTap={handleTermTap}
      spellCheck={true}
    />
  );
  
  return (
    <View style={styles.container}>
      <ScrollView>
        {renderTextRegions()}
        {renderTextEditor()}
        <ConfidenceIndicator confidence={ocrResult.confidence} />
      </ScrollView>
      <ActionButtons
        onConfirm={() => onConfirm()}
        onEdit={() => onEdit(editedText)}
        onRetake={onRetake}
      />
    </View>
  );
};
```

### **Batch Processing & Upload**

#### **Batch OCR Manager**
```typescript
interface BatchOCRConfig {
  // Configuración de lotes
  maxBatchSize: number;
  processingMode: 'sequential' | 'parallel';
  
  // Prioridades
  priorityQueue: boolean;
  maxConcurrent: number;
  
  // Calidad
  qualityThreshold: number;
  retryFailedItems: boolean;
  
  // Upload
  autoUpload: boolean;
  uploadWhenWifi: boolean;
}

class BatchOCRManager {
  // Gestión de lotes
  async addToBatch(imageUri: string, priority?: Priority): Promise<string>
  async processBatch(): Promise<BatchResult[]>
  async processItem(itemId: string): Promise<OCRResult>
  
  // Monitoreo
  getBatchProgress(): Promise<BatchProgress>
  getFailedItems(): Promise<FailedItem[]>
  
  // Upload automático
  async uploadResults(): Promise<UploadResult[]>
  async scheduleUpload(results: OCRResult[]): Promise<void>
  
  // Limpieza
  async cleanupProcessedItems(): Promise<void>
  async clearBatch(): Promise<void>
}

interface BatchProgress {
  total: number;
  processed: number;
  failed: number;
  inProgress: number;
  estimatedTimeRemaining: number; // segundos
}
```

---

## 👤 **FASE 2.5: USER ONBOARDING MEJORADO**
### *Duración: 3 días | Prioridad: MEDIA*

### **Objetivo**
Crear experiencia de onboarding fluida y educativa que guíe a los usuarios médicos a través de las capacidades de AxoNote, maximizando la adopción y el engagement inicial.

### **Onboarding Flow Interactivo**

#### **Welcome Sequence**
```typescript
interface OnboardingConfig {
  // Personalización por rol
  userRoles: ('student' | 'resident' | 'doctor' | 'professor' | 'researcher')[];
  
  // Contenido adaptativo
  adaptiveContent: boolean;
  skipOptions: boolean;
  
  // Progreso
  showProgress: boolean;
  allowSkip: boolean;
  saveProgress: boolean;
  
  // Analytics
  trackInteractions: boolean;
  measureEngagement: boolean;
}

interface OnboardingStep {
  id: string;
  title: string;
  description: string;
  component: React.ComponentType<any>;
  duration: number; // segundos estimados
  required: boolean;
  prerequisites?: string[];
}

class OnboardingService {
  // Gestión de flujo
  async startOnboarding(userProfile: UserProfile): Promise<void>
  async completeStep(stepId: string): Promise<void>
  async skipStep(stepId: string, reason?: string): Promise<void>
  
  // Personalización
  async getPersonalizedSteps(userRole: UserRole): Promise<OnboardingStep[]>
  async adaptContentToUser(content: OnboardingContent): Promise<OnboardingContent>
  
  // Progreso
  getProgress(): Promise<OnboardingProgress>
  async saveProgress(): Promise<void>
  async resumeOnboarding(): Promise<void>
  
  // Analytics
  async trackStepCompletion(stepId: string, timeSpent: number): Promise<void>
  async trackUserEngagement(interactions: Interaction[]): Promise<void>
}
```

#### **Interactive Tutorial Components**
```typescript
// Step 1: Welcome & Role Selection
const WelcomeStep: React.FC = () => {
  const [selectedRole, setSelectedRole] = useState<UserRole | null>(null);
  
  return (
    <OnboardingStep>
      <AnimatedHeader title="Benvenuto in AxoNote" />
      <RoleSelector
        roles={medicalRoles}
        onSelect={setSelectedRole}
        showDescriptions={true}
      />
      <ContinueButton
        enabled={selectedRole !== null}
        onPress={() => completeStep('welcome', { role: selectedRole })}
      />
    </OnboardingStep>
  );
};

// Step 2: Recording Demo
const RecordingDemoStep: React.FC = () => {
  const [demoCompleted, setDemoCompleted] = useState(false);
  
  return (
    <OnboardingStep>
      <InteractiveDemo
        title="Registra la tua prima lezione"
        description="Prova a registrare un breve audio per vedere come funziona"
        demoType="recording"
        onComplete={() => setDemoCompleted(true)}
      />
      <FeatureHighlight
        features={['VAD', 'Compressione', 'Upload automatico']}
      />
    </OnboardingStep>
  );
};

// Step 3: Camera & OCR Demo
const CameraDemoStep: React.FC = () => {
  return (
    <OnboardingStep>
      <InteractiveDemo
        title="Digitalizza documenti medici"
        description="Fotografa un documento per vedere l'OCR in azione"
        demoType="camera"
        mockDocument={sampleMedicalDocument}
      />
      <FeatureShowcase
        features={['Rilevamento automatico', 'OCR medico', 'Terminologia']}
      />
    </OnboardingStep>
  );
};

// Step 4: Study Features
const StudyFeaturesStep: React.FC = () => {
  return (
    <OnboardingStep>
      <FeatureCarousel
        features={[
          {
            title: 'Micro-Memos',
            description: 'Flashcard generate automaticamente',
            demo: <MicroMemoDemo />
          },
          {
            title: 'TTS Medico',
            description: 'Audio con pronuncia corretta',
            demo: <TTSDemo />
          },
          {
            title: 'Research Automatico',
            description: 'Fonti mediche verificate',
            demo: <ResearchDemo />
          }
        ]}
      />
    </OnboardingStep>
  );
};

// Step 5: Sync & Notion
const SyncSetupStep: React.FC = () => {
  const [notionConnected, setNotionConnected] = useState(false);
  
  return (
    <OnboardingStep>
      <SyncExplanation />
      <NotionConnector
        onConnect={() => setNotionConnected(true)}
        optional={true}
      />
      <OfflineModeExplanation />
    </OnboardingStep>
  );
};
```

### **Progressive Disclosure**

#### **Feature Discovery System**
```typescript
interface FeatureDiscoveryConfig {
  // Triggers de discovery
  triggers: {
    usageCount: number;
    timeSpent: number;
    contextualRelevance: boolean;
  };
  
  // Presentación
  presentationStyle: 'tooltip' | 'modal' | 'inline' | 'spotlight';
  timing: 'immediate' | 'delayed' | 'contextual';
  
  // Persistencia
  rememberDismissals: boolean;
  maxShowCount: number;
}

class FeatureDiscoveryService {
  // Discovery management
  async shouldShowFeature(featureId: string): Promise<boolean>
  async showFeatureDiscovery(feature: Feature): Promise<void>
  async dismissFeature(featureId: string): Promise<void>
  
  // Contextual discovery
  async discoverFeaturesForContext(context: AppContext): Promise<Feature[]>
  async scheduleContextualDiscovery(feature: Feature, context: AppContext): Promise<void>
  
  // Analytics
  async trackFeatureDiscovery(featureId: string, action: DiscoveryAction): Promise<void>
  getDiscoveryStats(): Promise<DiscoveryStats>
}

// Componentes de discovery
const FeatureSpotlight: React.FC<{
  feature: Feature;
  targetRef: React.RefObject<View>;
  onDismiss: () => void;
}> = ({ feature, targetRef, onDismiss }) => {
  return (
    <Spotlight target={targetRef}>
      <FeatureCard
        title={feature.title}
        description={feature.description}
        benefits={feature.benefits}
        onTryNow={() => feature.action()}
        onDismiss={onDismiss}
      />
    </Spotlight>
  );
};
```

### **Help & Support Integration**

#### **Contextual Help System**
```typescript
interface HelpSystemConfig {
  // Tipos de ayuda
  helpTypes: ('tooltip' | 'guide' | 'video' | 'article' | 'chat')[];
  
  // Contextualización
  contextAware: boolean;
  userRoleSpecific: boolean;
  
  // Contenido
  multiLanguage: boolean;
  offlineContent: boolean;
  
  // Interacción
  searchEnabled: boolean;
  feedbackEnabled: boolean;
}

class ContextualHelpService {
  // Help content
  async getHelpForContext(context: AppContext): Promise<HelpContent[]>
  async searchHelp(query: string): Promise<HelpResult[]>
  async getPopularHelp(): Promise<HelpContent[]>
  
  // Interactive help
  async startGuidedTour(tourId: string): Promise<void>
  async showTooltip(elementId: string): Promise<void>
  async openHelpArticle(articleId: string): Promise<void>
  
  // Feedback
  async submitFeedback(feedback: HelpFeedback): Promise<void>
  async rateHelpfulness(contentId: string, rating: number): Promise<void>
  
  // Analytics
  async trackHelpUsage(contentId: string, action: HelpAction): Promise<void>
  getHelpAnalytics(): Promise<HelpAnalytics>
}

// Componentes de ayuda
const ContextualHelpButton: React.FC<{
  context: string;
  position: 'top-right' | 'bottom-right' | 'floating';
}> = ({ context, position }) => {
  const [helpVisible, setHelpVisible] = useState(false);
  const helpContent = useContextualHelp(context);
  
  return (
    <>
      <HelpButton
        position={position}
        onPress={() => setHelpVisible(true)}
        hasNewContent={helpContent.hasUpdates}
      />
      <HelpModal
        visible={helpVisible}
        content={helpContent}
        onClose={() => setHelpVisible(false)}
      />
    </>
  );
};
```

---

## 📊 **MÉTRICAS Y KPIs DEL SPRINT**

### **Objetivos Cuantitativos**

#### **Performance Targets**
```typescript
interface Sprint2Targets {
  // Mobile App
  mobileApp: {
    appSize: number; // < 50MB
    startupTime: number; // < 3 segundos
    recordingLatency: number; // < 100ms
    ocrProcessingTime: number; // < 5 segundos/página
    offlineFunctionality: number; // 95% features disponibles
  };
  
  // PWA Enhancement
  pwa: {
    installRate: number; // > 30%
    pwaScore: number; // > 95
    cacheHitRatio: number; // > 80%
    offlineUsability: number; // 90% features
  };
  
  // User Experience
  userExperience: {
    onboardingCompletion: number; // > 85%
    featureDiscovery: number; // > 70%
    userSatisfaction: number; // > 4.5/5
    supportTickets: number; // < 5% usuarios
  };
  
  // Technical Quality
  technical: {
    crashRate: number; // < 0.1%
    memoryUsage: number; // < 150MB
    batteryImpact: number; // < 2% por hora
    syncReliability: number; // > 99%
  };
}
```

#### **User Adoption Metrics**
```typescript
interface AdoptionMetrics {
  // Engagement
  dailyActiveUsers: number;
  sessionDuration: number; // minutos
  featureUsage: {
    recording: number; // % usuarios
    camera: number;
    study: number;
    sync: number;
  };
  
  // Retention
  dayOneRetention: number; // %
  daySevenRetention: number; // %
  dayThirtyRetention: number; // %
  
  // Quality
  userRating: number; // 1-5
  npsScore: number; // -100 a +100
  supportSatisfaction: number; // %
}
```

### **Criterios de Éxito**

#### **Funcionales**
- ✅ **App móvil nativa** funcional en iOS y Android
- ✅ **PWA mejorada** con score >95 en Lighthouse
- ✅ **Offline-first** con 95%+ funcionalidad sin conexión
- ✅ **Camera & OCR** con precisión >90% en documentos médicos
- ✅ **Onboarding** con completion rate >85%

#### **Técnicos**
- ✅ **Performance** cumple todos los targets definidos
- ✅ **Reliability** con crash rate <0.1%
- ✅ **Security** sin vulnerabilidades críticas
- ✅ **Accessibility** cumple WCAG 2.1 AA
- ✅ **Cross-platform** funcionalidad consistente

#### **Negocio**
- ✅ **User satisfaction** >4.5/5 en ratings
- ✅ **Feature adoption** >70% para features principales
- ✅ **Support load** <5% usuarios requieren soporte
- ✅ **Market readiness** para lanzamiento público

---

## 🚀 **PLAN DE IMPLEMENTACIÓN**

### **Semana 1: React Native Foundation**
- **Días 1-2**: Setup proyecto React Native + configuración base
- **Días 3-4**: Implementación componentes de recording
- **Días 5-7**: Desarrollo sistema de navegación y estado

### **Semana 2: Core Mobile Features**
- **Días 1-3**: Camera integration y document detection
- **Días 4-5**: OCR on-device implementation
- **Días 6-7**: Offline storage con SQLite

### **Semana 3: Sync & PWA Enhancement**
- **Días 1-3**: Background sync y conflict resolution
- **Días 4-5**: PWA advanced features
- **Días 6-7**: Performance optimization

### **Semana 4: Polish & Testing**
- **Días 1-2**: User onboarding implementation
- **Días 3-4**: Testing completo y bug fixes
- **Días 5-7**: Documentation y deployment preparation

---

## 📁 **ESTRUCTURA DE ARCHIVOS RESULTANTE**

```
axonote/
├── apps/
│   ├── mobile/                    # NEW - React Native App
│   │   ├── src/
│   │   │   ├── components/
│   │   │   ├── screens/
│   │   │   ├── services/
│   │   │   ├── store/
│   │   │   └── utils/
│   │   ├── app.json
│   │   └── package.json
│   ├── web/                       # ENHANCED - PWA Mejorada
│   │   ├── app/
│   │   ├── components/
│   │   ├── lib/
│   │   ├── public/
│   │   │   ├── sw.js              # NEW - Service Worker avanzado
│   │   │   └── manifest.json      # ENHANCED
│   │   └── package.json
│   └── api/                       # ENHANCED - Endpoints móviles
│       └── app/
│           └── api/v1/endpoints/
│               ├── mobile.py      # NEW
│               └── sync.py        # NEW
├── shared/                        # NEW - Código compartido
│   ├── types/
│   ├── utils/
│   └── constants/
└── docs/                         # NEW - Documentación técnica
    ├── mobile/
    ├── pwa/
    └── api/
```

---

## 🎯 **PRÓXIMOS PASOS POST-SPRINT 2**

### **Sprint 3: AI Avanzada (4-5 semanas)**
1. **Learning Analytics**: IA personalizada para optimización de aprendizaje
2. **Voice AI**: Conversational AI para estudio interactivo
3. **Advanced TTS**: Clonación de voz de profesores
4. **Multi-language**: Soporte idiomas médicos internacionales

### **Sprint 4: Enterprise & Escalabilidad (3-4 semanas)**
1. **Enterprise Features**: White-label, RBAC avanzado
2. **Scaling Architecture**: Microservicios, 10k+ usuarios concurrentes
3. **API Pública v2**: Ecosystem de integraciones
4. **LMS Integrations**: Moodle, Canvas, Blackboard

---

## ✅ **CONCLUSIÓN**

El **Sprint 2: Mobile & User Experience** transformará AxoNote en una plataforma verdaderamente multiplataforma con:

1. **📱 Experiencia móvil nativa** optimizada para profesionales médicos
2. **🌐 PWA de clase mundial** con funcionalidades avanzadas
3. **🔄 Arquitectura offline-first** robusta y confiable
4. **📷 Capacidades de digitalización** instantánea de documentos
5. **👤 Onboarding intuitivo** que maximiza la adopción

**Resultado esperado**: AxoNote estará listo para competir con las mejores aplicaciones móviles del mercado médico, proporcionando una experiencia de usuario excepcional que impulse la adopción masiva en instituciones médicas.

---

**Estado**: 🚀 **LISTO PARA EJECUCIÓN**  
**Sprint**: 2 - Mobile & User Experience  
**Fecha Inicio**: 11 Septiembre 2025  
**Fecha Estimada Finalización**: 2 Octubre 2025  
**Siguiente Sprint**: Sprint 3 - Inteligencia Artificial Avanzada

**🎯 AxoNote evolucionará de una plataforma web funcional a un ecosistema móvil completo que revolucionará la educación médica digital.**
