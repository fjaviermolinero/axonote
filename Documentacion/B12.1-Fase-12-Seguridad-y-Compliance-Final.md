# B12.1 - Fase 12: Seguridad y Compliance Final

## üìã Resumen

La **Fase 12** implementa las medidas de seguridad y compliance finales para Axonote, asegurando que el sistema cumple con los est√°ndares m√°s exigentes de seguridad m√©dica, protecci√≥n de datos y normativas como GDPR. Esta fase consolida todas las capas de seguridad necesarias para un entorno de producci√≥n m√©dico.

## üéØ Objetivos

### **Seguridad T√©cnica**
1. **Autenticaci√≥n robusta** con JWT + refresh tokens + MFA opcional
2. **Autorizaci√≥n granular** con RBAC (Role-Based Access Control)
3. **Cifrado completo** de datos en reposo y en tr√°nsito
4. **Rate limiting avanzado** con protecci√≥n DDoS
5. **Validaci√≥n de entrada** exhaustiva y sanitizaci√≥n
6. **Headers de seguridad** completos (CSP, HSTS, etc.)
7. **Auditor√≠a completa** de acciones y cambios

### **Compliance y Privacidad**
1. **GDPR compliance** completo con gesti√≥n de consentimientos
2. **Anonimizaci√≥n** de datos m√©dicos sensibles
3. **Retenci√≥n de datos** con pol√≠ticas autom√°ticas
4. **Backup cifrado** con recuperaci√≥n segura
5. **Logs de auditor√≠a** inmutables y trazables
6. **Gesti√≥n de incidentes** de seguridad

### **Monitoreo y Alertas**
1. **Detecci√≥n de intrusiones** en tiempo real
2. **Alertas de seguridad** autom√°ticas
3. **M√©tricas de seguridad** en dashboard
4. **An√°lisis de vulnerabilidades** continuo

## üèóÔ∏è Implementaci√≥n

### **1. Sistema de Autenticaci√≥n Avanzado**

#### **Modelos de Usuario y Roles**
```python
# models/user.py
from sqlalchemy import Column, String, Boolean, DateTime, Text, Enum
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
import uuid
import enum

class RolUsuario(str, enum.Enum):
    ADMIN = "admin"
    MEDICO = "medico"
    ESTUDIANTE = "estudiante"
    INVITADO = "invitado"

class Usuario(Base):
    __tablename__ = "usuarios"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, index=True, nullable=False)
    nombre_completo = Column(String(255), nullable=False)
    password_hash = Column(String(255), nullable=False)
    rol = Column(Enum(RolUsuario), default=RolUsuario.ESTUDIANTE)
    activo = Column(Boolean, default=True)
    verificado = Column(Boolean, default=False)
    
    # MFA
    mfa_habilitado = Column(Boolean, default=False)
    mfa_secreto = Column(String(255), nullable=True)
    
    # Metadatos de seguridad
    ultimo_acceso = Column(DateTime(timezone=True))
    intentos_fallidos = Column(Integer, default=0)
    bloqueado_hasta = Column(DateTime(timezone=True), nullable=True)
    
    # Consentimientos GDPR
    consentimientos = Column(JSONB, default={})
    fecha_consentimiento = Column(DateTime(timezone=True))
    
    # Auditor√≠a
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relaciones
    sesiones = relationship("SesionUsuario", back_populates="usuario")
    logs_auditoria = relationship("LogAuditoria", back_populates="usuario")

class SesionUsuario(Base):
    __tablename__ = "sesiones_usuario"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    usuario_id = Column(UUID(as_uuid=True), ForeignKey("usuarios.id"))
    token_jti = Column(String(255), unique=True, index=True)
    refresh_token_jti = Column(String(255), unique=True, index=True)
    
    # Metadatos de sesi√≥n
    ip_address = Column(String(45))  # IPv6 compatible
    user_agent = Column(Text)
    dispositivo_info = Column(JSONB)
    
    # Control de sesi√≥n
    activa = Column(Boolean, default=True)
    expira_en = Column(DateTime(timezone=True))
    ultimo_uso = Column(DateTime(timezone=True))
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    usuario = relationship("Usuario", back_populates="sesiones")
```

#### **Servicio de Autenticaci√≥n Mejorado**
```python
# services/auth_service.py
import secrets
import pyotp
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from passlib.context import CryptContext
from jose import JWTError, jwt

class ServicioAutenticacion:
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.algoritmo = "HS256"
        
    async def registrar_usuario(
        self, 
        db: Session,
        email: str,
        password: str,
        nombre_completo: str,
        rol: RolUsuario = RolUsuario.ESTUDIANTE
    ) -> Usuario:
        """Registra un nuevo usuario con validaciones de seguridad."""
        
        # Validar fortaleza de contrase√±a
        if not self._validar_password_seguro(password):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="La contrase√±a no cumple los requisitos de seguridad"
            )
        
        # Verificar si el usuario ya existe
        usuario_existente = db.query(Usuario).filter(Usuario.email == email).first()
        if usuario_existente:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="El email ya est√° registrado"
            )
        
        # Crear usuario
        password_hash = self.pwd_context.hash(password)
        usuario = Usuario(
            email=email,
            nombre_completo=nombre_completo,
            password_hash=password_hash,
            rol=rol
        )
        
        db.add(usuario)
        db.commit()
        db.refresh(usuario)
        
        # Log de auditor√≠a
        await self._log_evento_auditoria(
            db, usuario.id, "REGISTRO_USUARIO", 
            {"email": email, "rol": rol.value}
        )
        
        return usuario
    
    async def autenticar_usuario(
        self,
        db: Session,
        email: str,
        password: str,
        ip_address: str,
        user_agent: str,
        codigo_mfa: Optional[str] = None
    ) -> Dict[str, Any]:
        """Autentica usuario con MFA opcional."""
        
        usuario = db.query(Usuario).filter(Usuario.email == email).first()
        
        # Verificar si el usuario existe y est√° activo
        if not usuario or not usuario.activo:
            await self._log_intento_fallido(db, email, ip_address, "USUARIO_INEXISTENTE")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Credenciales inv√°lidas"
            )
        
        # Verificar si est√° bloqueado
        if usuario.bloqueado_hasta and usuario.bloqueado_hasta > datetime.utcnow():
            raise HTTPException(
                status_code=status.HTTP_423_LOCKED,
                detail="Usuario temporalmente bloqueado"
            )
        
        # Verificar contrase√±a
        if not self.pwd_context.verify(password, usuario.password_hash):
            usuario.intentos_fallidos += 1
            
            # Bloquear despu√©s de 5 intentos
            if usuario.intentos_fallidos >= 5:
                usuario.bloqueado_hasta = datetime.utcnow() + timedelta(minutes=30)
            
            db.commit()
            
            await self._log_intento_fallido(db, email, ip_address, "PASSWORD_INCORRECTO")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Credenciales inv√°lidas"
            )
        
        # Verificar MFA si est√° habilitado
        if usuario.mfa_habilitado:
            if not codigo_mfa:
                raise HTTPException(
                    status_code=status.HTTP_200_OK,
                    detail="MFA requerido",
                    headers={"X-MFA-Required": "true"}
                )
            
            if not self._verificar_codigo_mfa(usuario.mfa_secreto, codigo_mfa):
                await self._log_intento_fallido(db, email, ip_address, "MFA_INCORRECTO")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="C√≥digo MFA inv√°lido"
                )
        
        # Reset intentos fallidos
        usuario.intentos_fallidos = 0
        usuario.bloqueado_hasta = None
        usuario.ultimo_acceso = datetime.utcnow()
        
        # Crear sesi√≥n
        sesion = await self._crear_sesion(db, usuario, ip_address, user_agent)
        
        # Generar tokens
        access_token = self._crear_access_token(usuario, sesion.token_jti)
        refresh_token = self._crear_refresh_token(usuario, sesion.refresh_token_jti)
        
        db.commit()
        
        await self._log_evento_auditoria(
            db, usuario.id, "LOGIN_EXITOSO", 
            {"ip": ip_address, "user_agent": user_agent}
        )
        
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer",
            "usuario": {
                "id": str(usuario.id),
                "email": usuario.email,
                "nombre_completo": usuario.nombre_completo,
                "rol": usuario.rol.value
            }
        }
    
    def _validar_password_seguro(self, password: str) -> bool:
        """Valida que la contrase√±a cumpla requisitos de seguridad."""
        if len(password) < 12:
            return False
        
        tiene_mayuscula = any(c.isupper() for c in password)
        tiene_minuscula = any(c.islower() for c in password)
        tiene_numero = any(c.isdigit() for c in password)
        tiene_especial = any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?" for c in password)
        
        return all([tiene_mayuscula, tiene_minuscula, tiene_numero, tiene_especial])
    
    async def habilitar_mfa(self, db: Session, usuario_id: str) -> str:
        """Habilita MFA para un usuario y retorna el secreto."""
        usuario = db.query(Usuario).filter(Usuario.id == usuario_id).first()
        if not usuario:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        secreto = pyotp.random_base32()
        usuario.mfa_secreto = secreto
        usuario.mfa_habilitado = True
        
        db.commit()
        
        await self._log_evento_auditoria(
            db, usuario.id, "MFA_HABILITADO", {}
        )
        
        return secreto
```

### **2. Rate Limiting Avanzado**

```python
# services/rate_limiter_service.py
import redis
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import HTTPException, Request
from enum import Enum

class TipoLimite(str, Enum):
    POR_IP = "ip"
    POR_USUARIO = "user"
    POR_ENDPOINT = "endpoint"
    GLOBAL = "global"

class ServicioRateLimiting:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        
    async def verificar_limite(
        self,
        request: Request,
        limite_requests: int,
        ventana_segundos: int,
        tipo: TipoLimite = TipoLimite.POR_IP,
        usuario_id: Optional[str] = None
    ) -> bool:
        """Verifica si se ha excedido el l√≠mite de requests."""
        
        # Generar clave seg√∫n el tipo
        clave = self._generar_clave_limite(request, tipo, usuario_id)
        
        # Implementar sliding window con Redis
        ahora = datetime.utcnow()
        ventana_inicio = ahora - timedelta(seconds=ventana_segundos)
        
        pipe = self.redis.pipeline()
        
        # Remover requests antiguos
        pipe.zremrangebyscore(clave, 0, ventana_inicio.timestamp())
        
        # Contar requests actuales
        pipe.zcard(clave)
        
        # A√±adir request actual
        pipe.zadd(clave, {str(ahora.timestamp()): ahora.timestamp()})
        
        # Establecer expiraci√≥n
        pipe.expire(clave, ventana_segundos)
        
        resultados = pipe.execute()
        requests_actuales = resultados[1]
        
        if requests_actuales >= limite_requests:
            # Log del rate limit excedido
            await self._log_rate_limit_excedido(request, tipo, usuario_id, requests_actuales)
            
            raise HTTPException(
                status_code=429,
                detail="L√≠mite de requests excedido",
                headers={
                    "X-RateLimit-Limit": str(limite_requests),
                    "X-RateLimit-Remaining": "0",
                    "X-RateLimit-Reset": str(int((ahora + timedelta(seconds=ventana_segundos)).timestamp()))
                }
            )
        
        return True
    
    def _generar_clave_limite(
        self, 
        request: Request, 
        tipo: TipoLimite, 
        usuario_id: Optional[str]
    ) -> str:
        """Genera la clave Redis para el rate limiting."""
        
        if tipo == TipoLimite.POR_IP:
            ip = self._obtener_ip_real(request)
            return f"rate_limit:ip:{ip}"
        elif tipo == TipoLimite.POR_USUARIO and usuario_id:
            return f"rate_limit:user:{usuario_id}"
        elif tipo == TipoLimite.POR_ENDPOINT:
            endpoint = request.url.path
            return f"rate_limit:endpoint:{endpoint}"
        else:
            return "rate_limit:global"
    
    def _obtener_ip_real(self, request: Request) -> str:
        """Obtiene la IP real considerando proxies."""
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
        
        return request.client.host
```

### **3. Cifrado de Datos Sensibles**

```python
# services/encryption_service.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os
from typing import Union

class ServicioCifrado:
    def __init__(self, master_key: str):
        self.master_key = master_key.encode()
        
    def _generar_clave_derivada(self, salt: bytes) -> bytes:
        """Genera una clave derivada usando PBKDF2."""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        return base64.urlsafe_b64encode(kdf.derive(self.master_key))
    
    def cifrar_datos(self, datos: Union[str, bytes]) -> str:
        """Cifra datos usando Fernet (AES 128 en modo CBC)."""
        if isinstance(datos, str):
            datos = datos.encode('utf-8')
        
        # Generar salt √∫nico
        salt = os.urandom(16)
        clave = self._generar_clave_derivada(salt)
        
        f = Fernet(clave)
        datos_cifrados = f.encrypt(datos)
        
        # Combinar salt + datos cifrados
        resultado = base64.urlsafe_b64encode(salt + datos_cifrados)
        return resultado.decode('utf-8')
    
    def descifrar_datos(self, datos_cifrados: str) -> str:
        """Descifra datos previamente cifrados."""
        try:
            datos_completos = base64.urlsafe_b64decode(datos_cifrados.encode('utf-8'))
            
            # Extraer salt y datos
            salt = datos_completos[:16]
            datos_cifrados_bytes = datos_completos[16:]
            
            # Regenerar clave
            clave = self._generar_clave_derivada(salt)
            
            f = Fernet(clave)
            datos_descifrados = f.decrypt(datos_cifrados_bytes)
            
            return datos_descifrados.decode('utf-8')
        except Exception as e:
            raise ValueError(f"Error al descifrar datos: {str(e)}")

# Modelo con campos cifrados
class ClassSessionSegura(Base):
    __tablename__ = "class_sessions_seguras"
    
    # Campos normales
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    fecha = Column(Date, nullable=False)
    asignatura = Column(String(200), nullable=False)
    
    # Campos cifrados (almacenados como texto)
    transcripcion_cifrada = Column(Text)  # transcripcion_md cifrada
    resumen_cifrado = Column(Text)       # resumen_md cifrado
    notas_privadas_cifradas = Column(Text)  # notas personales cifradas
    
    @property
    def transcripcion_md(self) -> Optional[str]:
        """Descifra y retorna la transcripci√≥n."""
        if not self.transcripcion_cifrada:
            return None
        return servicio_cifrado.descifrar_datos(self.transcripcion_cifrada)
    
    @transcripcion_md.setter
    def transcripcion_md(self, valor: str):
        """Cifra y almacena la transcripci√≥n."""
        if valor:
            self.transcripcion_cifrada = servicio_cifrado.cifrar_datos(valor)
        else:
            self.transcripcion_cifrada = None
```

### **4. Sistema de Auditor√≠a Completo**

```python
# models/auditoria.py
class TipoEventoAuditoria(str, enum.Enum):
    # Autenticaci√≥n
    LOGIN_EXITOSO = "login_exitoso"
    LOGIN_FALLIDO = "login_fallido"
    LOGOUT = "logout"
    CAMBIO_PASSWORD = "cambio_password"
    MFA_HABILITADO = "mfa_habilitado"
    MFA_DESHABILITADO = "mfa_deshabilitado"
    
    # Datos
    CREACION_SESION = "creacion_sesion"
    MODIFICACION_SESION = "modificacion_sesion"
    ELIMINACION_SESION = "eliminacion_sesion"
    ACCESO_DATOS_SENSIBLES = "acceso_datos_sensibles"
    EXPORTACION_DATOS = "exportacion_datos"
    
    # Sistema
    CAMBIO_CONFIGURACION = "cambio_configuracion"
    ERROR_SISTEMA = "error_sistema"
    BACKUP_CREADO = "backup_creado"
    BACKUP_RESTAURADO = "backup_restaurado"
    
    # Seguridad
    INTENTO_ACCESO_NO_AUTORIZADO = "intento_acceso_no_autorizado"
    RATE_LIMIT_EXCEDIDO = "rate_limit_excedido"
    DETECCION_ANOMALIA = "deteccion_anomalia"

class LogAuditoria(Base):
    __tablename__ = "logs_auditoria"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Informaci√≥n del evento
    tipo_evento = Column(Enum(TipoEventoAuditoria), nullable=False)
    descripcion = Column(Text, nullable=False)
    resultado = Column(String(50))  # "exitoso", "fallido", "bloqueado"
    
    # Usuario y sesi√≥n
    usuario_id = Column(UUID(as_uuid=True), ForeignKey("usuarios.id"), nullable=True)
    sesion_id = Column(UUID(as_uuid=True), nullable=True)
    
    # Contexto t√©cnico
    ip_address = Column(String(45))
    user_agent = Column(Text)
    endpoint = Column(String(255))
    metodo_http = Column(String(10))
    
    # Datos del evento (JSON)
    datos_evento = Column(JSONB)
    datos_antes = Column(JSONB)  # Estado antes del cambio
    datos_despues = Column(JSONB)  # Estado despu√©s del cambio
    
    # Metadatos de seguridad
    hash_integridad = Column(String(64))  # SHA-256 del evento
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relaciones
    usuario = relationship("Usuario", back_populates="logs_auditoria")
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Generar hash de integridad
        self.hash_integridad = self._generar_hash_integridad()
    
    def _generar_hash_integridad(self) -> str:
        """Genera hash SHA-256 para verificar integridad del log."""
        import hashlib
        import json
        
        datos_hash = {
            "tipo_evento": self.tipo_evento,
            "descripcion": self.descripcion,
            "usuario_id": str(self.usuario_id) if self.usuario_id else None,
            "ip_address": self.ip_address,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
            "datos_evento": self.datos_evento
        }
        
        json_str = json.dumps(datos_hash, sort_keys=True)
        return hashlib.sha256(json_str.encode()).hexdigest()

# Servicio de auditor√≠a
class ServicioAuditoria:
    def __init__(self, db: Session):
        self.db = db
    
    async def log_evento(
        self,
        tipo_evento: TipoEventoAuditoria,
        descripcion: str,
        usuario_id: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        endpoint: Optional[str] = None,
        metodo_http: Optional[str] = None,
        datos_evento: Optional[Dict] = None,
        datos_antes: Optional[Dict] = None,
        datos_despues: Optional[Dict] = None,
        resultado: str = "exitoso"
    ):
        """Registra un evento de auditor√≠a."""
        
        log_entry = LogAuditoria(
            tipo_evento=tipo_evento,
            descripcion=descripcion,
            resultado=resultado,
            usuario_id=usuario_id,
            ip_address=ip_address,
            user_agent=user_agent,
            endpoint=endpoint,
            metodo_http=metodo_http,
            datos_evento=datos_evento or {},
            datos_antes=datos_antes,
            datos_despues=datos_despues
        )
        
        self.db.add(log_entry)
        self.db.commit()
        
        # Enviar a sistema de monitoreo si es evento cr√≠tico
        if self._es_evento_critico(tipo_evento):
            await self._enviar_alerta_seguridad(log_entry)
    
    def _es_evento_critico(self, tipo_evento: TipoEventoAuditoria) -> bool:
        """Determina si un evento requiere alerta inmediata."""
        eventos_criticos = {
            TipoEventoAuditoria.INTENTO_ACCESO_NO_AUTORIZADO,
            TipoEventoAuditoria.RATE_LIMIT_EXCEDIDO,
            TipoEventoAuditoria.DETECCION_ANOMALIA,
            TipoEventoAuditoria.ERROR_SISTEMA
        }
        return tipo_evento in eventos_criticos
```

### **5. Compliance GDPR**

```python
# models/gdpr.py
class ConsentimientoGDPR(Base):
    __tablename__ = "consentimientos_gdpr"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    usuario_id = Column(UUID(as_uuid=True), ForeignKey("usuarios.id"))
    
    # Tipos de consentimiento
    procesamiento_datos_medicos = Column(Boolean, default=False)
    analisis_ia = Column(Boolean, default=False)
    almacenamiento_transcripciones = Column(Boolean, default=False)
    integracion_notion = Column(Boolean, default=False)
    cookies_analiticas = Column(Boolean, default=False)
    
    # Metadatos del consentimiento
    version_politica = Column(String(50))
    ip_consentimiento = Column(String(45))
    user_agent_consentimiento = Column(Text)
    fecha_consentimiento = Column(DateTime(timezone=True), server_default=func.now())
    fecha_revocacion = Column(DateTime(timezone=True), nullable=True)
    
    # Estado
    activo = Column(Boolean, default=True)
    
    usuario = relationship("Usuario")

class SolicitudDatos(Base):
    __tablename__ = "solicitudes_datos"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    usuario_id = Column(UUID(as_uuid=True), ForeignKey("usuarios.id"))
    
    tipo_solicitud = Column(Enum(TipoSolicitudDatos))
    estado = Column(Enum(EstadoSolicitud), default=EstadoSolicitud.PENDIENTE)
    
    # Fechas
    fecha_solicitud = Column(DateTime(timezone=True), server_default=func.now())
    fecha_procesamiento = Column(DateTime(timezone=True), nullable=True)
    fecha_completado = Column(DateTime(timezone=True), nullable=True)
    
    # Archivos generados
    archivo_exportacion = Column(String(500), nullable=True)
    hash_archivo = Column(String(64), nullable=True)
    
    notas_procesamiento = Column(Text, nullable=True)
    
    usuario = relationship("Usuario")

# Servicio GDPR
class ServicioGDPR:
    def __init__(self, db: Session, servicio_cifrado: ServicioCifrado):
        self.db = db
        self.cifrado = servicio_cifrado
    
    async def exportar_datos_usuario(self, usuario_id: str) -> str:
        """Exporta todos los datos de un usuario (derecho de portabilidad)."""
        
        usuario = self.db.query(Usuario).filter(Usuario.id == usuario_id).first()
        if not usuario:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        # Recopilar todos los datos
        datos_exportacion = {
            "informacion_personal": {
                "email": usuario.email,
                "nombre_completo": usuario.nombre_completo,
                "fecha_registro": usuario.created_at.isoformat(),
                "ultimo_acceso": usuario.ultimo_acceso.isoformat() if usuario.ultimo_acceso else None
            },
            "sesiones_clase": [],
            "consentimientos": [],
            "logs_auditoria": []
        }
        
        # Sesiones de clase
        sesiones = self.db.query(ClassSession).filter(
            ClassSession.usuario_id == usuario_id
        ).all()
        
        for sesion in sesiones:
            datos_sesion = {
                "id": str(sesion.id),
                "fecha": sesion.fecha.isoformat(),
                "asignatura": sesion.asignatura,
                "tema": sesion.tema,
                "duracion_minutos": sesion.duracion_minutos,
                "transcripcion": sesion.transcripcion_md,  # Se descifra autom√°ticamente
                "resumen": sesion.resumen_md,
                "fecha_creacion": sesion.created_at.isoformat()
            }
            datos_exportacion["sesiones_clase"].append(datos_sesion)
        
        # Consentimientos
        consentimientos = self.db.query(ConsentimientoGDPR).filter(
            ConsentimientoGDPR.usuario_id == usuario_id
        ).all()
        
        for consentimiento in consentimientos:
            datos_exportacion["consentimientos"].append({
                "fecha": consentimiento.fecha_consentimiento.isoformat(),
                "version_politica": consentimiento.version_politica,
                "procesamiento_datos_medicos": consentimiento.procesamiento_datos_medicos,
                "analisis_ia": consentimiento.analisis_ia,
                "activo": consentimiento.activo
            })
        
        # Generar archivo JSON
        import json
        import tempfile
        import hashlib
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(datos_exportacion, f, indent=2, ensure_ascii=False)
            archivo_path = f.name
        
        # Calcular hash del archivo
        with open(archivo_path, 'rb') as f:
            hash_archivo = hashlib.sha256(f.read()).hexdigest()
        
        # Registrar solicitud
        solicitud = SolicitudDatos(
            usuario_id=usuario_id,
            tipo_solicitud=TipoSolicitudDatos.EXPORTACION,
            estado=EstadoSolicitud.COMPLETADO,
            fecha_procesamiento=datetime.utcnow(),
            fecha_completado=datetime.utcnow(),
            archivo_exportacion=archivo_path,
            hash_archivo=hash_archivo
        )
        
        self.db.add(solicitud)
        self.db.commit()
        
        return archivo_path
    
    async def eliminar_datos_usuario(self, usuario_id: str, confirmar: bool = False):
        """Elimina todos los datos de un usuario (derecho al olvido)."""
        
        if not confirmar:
            raise HTTPException(
                status_code=400, 
                detail="Debe confirmar expl√≠citamente la eliminaci√≥n"
            )
        
        usuario = self.db.query(Usuario).filter(Usuario.id == usuario_id).first()
        if not usuario:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        # Anonimizar en lugar de eliminar (para mantener integridad de auditor√≠a)
        usuario.email = f"usuario_anonimizado_{uuid.uuid4().hex[:8]}@eliminado.local"
        usuario.nombre_completo = "Usuario Eliminado"
        usuario.password_hash = "ELIMINADO"
        usuario.activo = False
        
        # Eliminar datos sensibles de sesiones
        sesiones = self.db.query(ClassSession).filter(
            ClassSession.usuario_id == usuario_id
        ).all()
        
        for sesion in sesiones:
            sesion.transcripcion_md = None
            sesion.resumen_md = None
            sesion.ampliacion_md = None
            sesion.glosario_json = {}
            sesion.preguntas_json = {}
            sesion.tarjetas_json = {}
        
        # Marcar consentimientos como revocados
        self.db.query(ConsentimientoGDPR).filter(
            ConsentimientoGDPR.usuario_id == usuario_id
        ).update({
            "activo": False,
            "fecha_revocacion": datetime.utcnow()
        })
        
        self.db.commit()
        
        # Log de auditor√≠a
        await self._log_eliminacion_datos(usuario_id)
```

### **6. Monitoreo de Seguridad**

```python
# services/security_monitoring.py
class ServicioMonitoreoSeguridad:
    def __init__(self, db: Session, redis_client: redis.Redis):
        self.db = db
        self.redis = redis_client
    
    async def detectar_anomalias_acceso(self, usuario_id: str, ip_address: str):
        """Detecta patrones an√≥malos de acceso."""
        
        # Obtener historial de IPs del usuario
        ips_historicas = await self._obtener_ips_usuario(usuario_id)
        
        # Verificar si es una IP nueva
        if ip_address not in ips_historicas:
            # Verificar geolocalizaci√≥n
            ubicacion_actual = await self._obtener_geolocalizacion(ip_address)
            ubicaciones_historicas = await self._obtener_ubicaciones_usuario(usuario_id)
            
            # Si es un pa√≠s/regi√≥n muy diferente, generar alerta
            if self._es_ubicacion_sospechosa(ubicacion_actual, ubicaciones_historicas):
                await self._generar_alerta_ubicacion_sospechosa(
                    usuario_id, ip_address, ubicacion_actual
                )
        
        # Detectar m√∫ltiples intentos de login
        intentos_recientes = await self._contar_intentos_login_recientes(ip_address)
        if intentos_recientes > 10:  # M√°s de 10 intentos en 1 hora
            await self._generar_alerta_fuerza_bruta(ip_address, intentos_recientes)
    
    async def analizar_patrones_uso(self, usuario_id: str):
        """Analiza patrones de uso para detectar anomal√≠as."""
        
        # Obtener actividad reciente
        actividad = await self._obtener_actividad_usuario(usuario_id, dias=30)
        
        # Detectar horarios inusuales
        horarios_normales = self._calcular_horarios_normales(actividad)
        hora_actual = datetime.utcnow().hour
        
        if not self._es_horario_normal(hora_actual, horarios_normales):
            await self._generar_alerta_horario_inusual(usuario_id, hora_actual)
        
        # Detectar volumen inusual de actividad
        actividad_promedio = self._calcular_actividad_promedio(actividad)
        actividad_hoy = await self._obtener_actividad_hoy(usuario_id)
        
        if actividad_hoy > actividad_promedio * 3:  # 3x m√°s actividad de lo normal
            await self._generar_alerta_actividad_inusual(usuario_id, actividad_hoy)
    
    async def verificar_integridad_sistema(self):
        """Verifica la integridad del sistema."""
        
        # Verificar integridad de logs de auditor√≠a
        logs_comprometidos = await self._verificar_integridad_logs()
        if logs_comprometidos:
            await self._generar_alerta_critica("LOGS_COMPROMETIDOS", {
                "logs_afectados": len(logs_comprometidos)
            })
        
        # Verificar configuraciones cr√≠ticas
        config_changes = await self._detectar_cambios_configuracion()
        if config_changes:
            await self._generar_alerta_configuracion(config_changes)
        
        # Verificar uso de recursos
        uso_recursos = await self._obtener_uso_recursos()
        if uso_recursos["cpu"] > 90 or uso_recursos["memoria"] > 90:
            await self._generar_alerta_recursos(uso_recursos)

# Middleware de monitoreo
class MiddlewareMonitoreoSeguridad:
    def __init__(self, servicio_monitoreo: ServicioMonitoreoSeguridad):
        self.monitoreo = servicio_monitoreo
    
    async def __call__(self, request: Request, call_next):
        inicio = time.time()
        
        # Obtener informaci√≥n de la request
        ip_address = self._obtener_ip_real(request)
        user_agent = request.headers.get("User-Agent", "")
        endpoint = request.url.path
        
        try:
            response = await call_next(request)
            
            # Monitorear respuestas sospechosas
            if response.status_code == 401:
                await self.monitoreo.registrar_intento_acceso_fallido(
                    ip_address, endpoint, user_agent
                )
            elif response.status_code == 429:
                await self.monitoreo.registrar_rate_limit_excedido(
                    ip_address, endpoint
                )
            
            # Monitorear tiempo de respuesta
            tiempo_respuesta = time.time() - inicio
            if tiempo_respuesta > 5.0:  # M√°s de 5 segundos
                await self.monitoreo.registrar_respuesta_lenta(
                    endpoint, tiempo_respuesta
                )
            
            return response
            
        except Exception as e:
            # Monitorear errores del sistema
            await self.monitoreo.registrar_error_sistema(
                endpoint, str(e), ip_address
            )
            raise
```

## ‚úÖ Checklist de Validaci√≥n

### **Autenticaci√≥n y Autorizaci√≥n**
- [ ] JWT con refresh tokens implementado
- [ ] MFA (TOTP) funcional
- [ ] Sistema de roles y permisos
- [ ] Bloqueo autom√°tico por intentos fallidos
- [ ] Validaci√≥n de contrase√±as seguras

### **Cifrado y Protecci√≥n de Datos**
- [ ] Cifrado AES-256 para datos sensibles
- [ ] Hashing seguro de contrase√±as (bcrypt)
- [ ] Claves derivadas con PBKDF2
- [ ] Comunicaci√≥n HTTPS obligatoria
- [ ] Headers de seguridad completos

### **Rate Limiting y Protecci√≥n DDoS**
- [ ] Rate limiting por IP implementado
- [ ] Rate limiting por usuario
- [ ] Protecci√≥n por endpoint
- [ ] Sliding window con Redis
- [ ] Alertas por exceso de requests

### **Auditor√≠a y Compliance**
- [ ] Logs de auditor√≠a inmutables
- [ ] Trazabilidad completa de acciones
- [ ] Exportaci√≥n de datos GDPR
- [ ] Eliminaci√≥n segura de datos
- [ ] Gesti√≥n de consentimientos

### **Monitoreo y Alertas**
- [ ] Detecci√≥n de anomal√≠as de acceso
- [ ] Alertas de seguridad en tiempo real
- [ ] Monitoreo de integridad del sistema
- [ ] An√°lisis de patrones de uso
- [ ] Dashboard de m√©tricas de seguridad

### **Backup y Recuperaci√≥n**
- [ ] Backups cifrados autom√°ticos
- [ ] Verificaci√≥n de integridad de backups
- [ ] Procedimientos de recuperaci√≥n
- [ ] Pruebas de restauraci√≥n
- [ ] Retenci√≥n de backups configurada

## üîß Troubleshooting

### **Problemas de Autenticaci√≥n**
```bash
# Verificar configuraci√≥n JWT
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "password123"}'

# Verificar MFA
curl -X POST http://localhost:8000/api/v1/auth/enable-mfa \
  -H "Authorization: Bearer $TOKEN"
```

### **Problemas de Rate Limiting**
```bash
# Verificar l√≠mites Redis
redis-cli
> KEYS rate_limit:*
> ZRANGE rate_limit:ip:192.168.1.1 0 -1 WITHSCORES
```

### **Verificar Cifrado**
```python
# Test de cifrado/descifrado
from app.services.encryption_service import ServicioCifrado

servicio = ServicioCifrado("clave_maestra_segura")
texto_original = "Datos m√©dicos sensibles"
texto_cifrado = servicio.cifrar_datos(texto_original)
texto_descifrado = servicio.descifrar_datos(texto_cifrado)

assert texto_original == texto_descifrado
```

## üìä M√©tricas de Seguridad

### **M√©tricas de Autenticaci√≥n**
- Intentos de login exitosos/fallidos por hora
- Tiempo promedio de autenticaci√≥n
- Uso de MFA por porcentaje de usuarios
- Sesiones activas concurrentes

### **M√©tricas de Protecci√≥n**
- Requests bloqueados por rate limiting
- IPs bloqueadas por comportamiento sospechoso
- Detecciones de anomal√≠as por d√≠a
- Tiempo de respuesta de alertas de seguridad

### **M√©tricas de Compliance**
- Solicitudes GDPR procesadas
- Tiempo de respuesta a solicitudes de datos
- Porcentaje de usuarios con consentimientos actualizados
- Auditor√≠as de seguridad completadas

## üöÄ Pr√≥ximos Pasos

1. **Implementar autenticaci√≥n JWT completa** con refresh tokens
2. **Configurar rate limiting** con Redis
3. **Establecer cifrado** de datos sensibles
4. **Crear sistema de auditor√≠a** completo
5. **Implementar compliance GDPR** 
6. **Configurar monitoreo** de seguridad
7. **Establecer backups cifrados**
8. **Crear dashboard** de m√©tricas de seguridad
9. **Documentar procedimientos** de seguridad
10. **Realizar pruebas** de penetraci√≥n

---

**Estado**: üîÑ En Progreso  
**Fase**: 12 - Seguridad y Compliance Final  
**Dependencias**: Todas las fases anteriores completadas  
**Tiempo Estimado**: 3-4 semanas  
**Prioridad**: Cr√≠tica
